"""event

Revision ID: ae7bbf17ac03
Revises: 3bdd27d82159
Create Date: 2020-06-22 13:41:06.888232

"""
import os.path
from alembic import op

from common.settings import BY_COUNT, COUNT, CREATE, PARTITION, PATH
from common.languages import lang_init


_ = lang_init()

# revision identifiers, used by Alembic.
revision = 'ae7bbf17ac03'
down_revision = '97640ee31d01'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('event_entities')

    if PARTITION == 0:
        intrvl = '1 day'
        period = 'day'
        form = 'YYYY_MM_DD'
        duration = 1095
    elif PARTITION == 1:
        intrvl = '1 week'
        period = 'week'
        form = 'YYYY_MM_DD'
        duration = 156
    elif PARTITION == 2:
        intrvl = '1 month'
        period = 'month'
        form = 'YYYY_MM'
        duration = 36
    elif PARTITION == 3:
        intrvl = '1 year'
        period = 'year'
        form = 'YYYY'
        duration = 3

    msg_str = _('Add new journal archive.')
    name_str = _('Archive name:')
    path_str = _('path:')

    if os.path.isdir(PATH):
        path = os.path.join(PATH, '')
    else:
        raise NotADirectoryError(PATH)

    if BY_COUNT:
        op.execute("""CREATE OR REPLACE FUNCTION insert_row()
                        RETURNS TRIGGER AS
                        $BODY$
                        -- Вставка данных в дочернюю таблицу по месяцу
                        DECLARE
                          partition_date TIMESTAMP;
                          partition_name TEXT;
                          sql TEXT;
                          index INT;
                        BEGIN
                          partition_date := date_trunc('{period}', NEW.created AT TIME ZONE 'UTC');
                          partition_name := format('event_%s', to_char(partition_date, '{form}'));
                          -- Если нет такой таблицы, то создается новая
                          IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN
                                PERFORM create_new_partition(partition_date, partition_name);
                          END IF;
                          -- Вставка данных
                          select format('INSERT INTO %s values ($1.*)', partition_name) into sql;
                          EXECUTE sql USING NEW;
                          -- Если количество записей равно заданному значению, то архивируются N записей (формат csv)
                          EXECUTE 'SELECT COUNT(*) FROM event' into index;
                          IF (index % {count} = 0) THEN
                            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
                            PERFORM archived(partition_date, index);
                          END IF;
                          return NEW;
                        END;
                        $BODY$
                        LANGUAGE plpgsql;""".format(period=period, form=form, count=COUNT))

        op.execute("""CREATE OR REPLACE FUNCTION archived(partition_date timestamp, index int)
                        RETURNS VOID AS
                        $BODY$
                        -- Архивирование предыдущих N записей (формат csv)
                        DECLARE
                          part TEXT;
                          path TEXT;
                          sql TEXT;
                          entity_id uuid = uuid_generate_v4();
                          event_id uuid = uuid_generate_v4();
                        BEGIN
                          part := format('event_%s', index);
                          path := format('{dir}%s.csv', part);
                          select format('COPY (SELECT * from event LIMIT {count} OFFSET (%s - {count}))
                                        TO ''%s'' With HEADER CSV', index, path) into sql;
                          EXECUTE sql;
                          select format('INSERT INTO entity (id, entity_type, entity_uuid) VALUES
                                        (''%s'', ''SECURITY'', NULL)', entity_id) into sql;
                          EXECUTE sql;
                          select format('INSERT INTO event (id, event_type, message, description, "user", entity_id)
                                        VALUES (''%s'', 0, ''{message}'',
                                        ''{name_str} %s, {path_str} {dir}'', ''system'', ''%s'')',
                                        event_id, part, entity_id) into sql;
                          EXECUTE sql;
                        END;
                        $BODY$
                        LANGUAGE plpgsql;""".format(dir=path, count=COUNT, message=msg_str,
                                                    name_str=name_str, path_str=path_str))
    else:
        op.execute("""CREATE OR REPLACE FUNCTION insert_row()
                        RETURNS TRIGGER AS
                        $BODY$
                        -- Вставка данных в дочернюю таблицу по заданному периоду
                        DECLARE
                          partition_date TIMESTAMP;
                          partition_name TEXT;
                          sql TEXT;
                        BEGIN
                          partition_date := date_trunc('{period}', NEW.created AT TIME ZONE 'UTC');
                          partition_name := format('event_%s', to_char(partition_date, '{form}'));
                          -- Если нет такой таблицы, то создается новая
                          IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN
                                PERFORM create_new_partition(partition_date, partition_name);
                                CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
                                PERFORM archived(partition_date);
                          END IF;
                        -- Вставка данных
                          select format('INSERT INTO %s values ($1.*)', partition_name) into sql;
                          EXECUTE sql USING NEW;
                          return NEW;
                        END;
                        $BODY$
                        LANGUAGE plpgsql;""".format(period=period, form=form))

        op.execute("""CREATE OR REPLACE FUNCTION archived(partition_date timestamp)
                        RETURNS VOID AS
                        $BODY$
                        -- Архивирование предыдущей дочерней таблицы (формат csv)
                        DECLARE
                          part TEXT;
                          path TEXT;
                          sql TEXT;
                          entity_id uuid = uuid_generate_v4();
                          event_id uuid = uuid_generate_v4();
                        BEGIN
                          part := format('event_%s', to_char(partition_date - interval '{intrvl}', '{form}'));
                          path := format('{dir}%s.csv', part);
                          IF (EXISTS (SELECT *
                                        FROM INFORMATION_SCHEMA.TABLES
                                        WHERE TABLE_SCHEMA = 'public'
                                        AND TABLE_NAME = part)) THEN
                             BEGIN
                               select format('COPY (SELECT * from event_%s) TO ''%s'' With HEADER CSV',
                                      to_char(partition_date - interval '{intrvl}', '{form}'), path) into sql;
                               EXECUTE sql;
                               select format('INSERT INTO entity (id, entity_type, entity_uuid) VALUES
                                             (''%s'', ''SECURITY'', NULL)', entity_id) into sql;
                               EXECUTE sql;
                               select format('INSERT INTO event
                                             (id, event_type, message, description, "user", entity_id)
                                             VALUES (''%s'', 0, ''{message}'',
                                             ''{name_str} %s, {path_str} {dir}'', ''system'', ''%s'')',
                                             event_id, part, entity_id) into sql;
                               EXECUTE sql;
                             END;
                          END IF;
                        END;
                        $BODY$
                        LANGUAGE plpgsql;""".format(intrvl=intrvl, form=form, dir=path, message=msg_str,
                                                    name_str=name_str, path_str=path_str))

    op.execute("""CREATE OR REPLACE FUNCTION create_new_partition(partition_date timestamp, partition_name text)
                    RETURNS VOID AS
                    $BODY$
                    -- Новая таблица, наследованная от основной таблицы event
                    DECLARE
                      sql TEXT;
                    BEGIN
                      -- Создание новой дочерней таблицы от event
                      select format('CREATE TABLE IF NOT EXISTS %s (CHECK (
                              created AT TIME ZONE ''UTC'' > ''%s'' AND
                              created AT TIME ZONE ''UTC'' <= ''%s''))
                              INHERITS (event)', partition_name, partition_date,
                                    partition_date + interval '{intrvl}') into sql;
                      EXECUTE sql;
                      PERFORM index_partition(partition_name);
                    END;
                    $BODY$
                    LANGUAGE plpgsql;""".format(intrvl=intrvl))

    op.execute("""CREATE OR REPLACE FUNCTION index_partition(partition_name text)
                    RETURNS VOID AS
                    $BODY$
                    -- индекс по дате создания события
                    BEGIN
                        EXECUTE 'CREATE INDEX IF NOT EXISTS ' || partition_name || '_idx ON ' || partition_name || ' (timezone(''UTC''::text, created))';
                    END;
                    $BODY$
                    LANGUAGE plpgsql;""")

    op.execute("""CREATE TRIGGER before_insert_row_trigger
                    BEFORE INSERT ON event
                    FOR EACH ROW EXECUTE PROCEDURE insert_row();""")

    op.execute("""CREATE OR REPLACE FUNCTION delete_parent_row()
                    RETURNS TRIGGER AS
                    $BODY$
                    -- удаление дублирующихся записей в родительской таблице
                    BEGIN
                        delete from only event where id = NEW.id;
                        RETURN null;
                    END;
                    $BODY$
                    LANGUAGE plpgsql;""")

    op.execute("""CREATE TRIGGER after_insert_row_trigger
                    AFTER INSERT ON event
                    FOR EACH ROW EXECUTE PROCEDURE delete_parent_row();""")

    op.execute("""CREATE OR REPLACE FUNCTION delete_partition()
                    RETURNS TRIGGER AS
                    $BODY$
                    -- Удаление данных из таблицы спустя 3 года
                    DECLARE
                      part TEXT;
                      sql TEXT;
                    BEGIN
                      IF (CURRENT_DATE >= '{create}'::date + {duration} * interval '{intrvl}') THEN
                        part := format('event_%s', to_char(CURRENT_DATE - {duration} * interval '{intrvl}', '{form}'));
                        IF (EXISTS (SELECT *
                             FROM INFORMATION_SCHEMA.TABLES
                             WHERE TABLE_SCHEMA = 'public'
                             AND TABLE_NAME = part)) THEN
                               BEGIN
                                 select format('DROP TABLE event_%s',
                                   to_char(CURRENT_DATE - {duration} * interval '{intrvl}', '{form}')) into sql;
                                 EXECUTE sql;
                               END;
                        END IF;
                      END IF;
                      return null;
                    END;
                    $BODY$
                    LANGUAGE plpgsql;""".format(create=CREATE, duration=duration, intrvl=intrvl, form=form))

    op.execute("""CREATE TRIGGER after_insert_row_for_delete_partition_trigger
                    AFTER INSERT ON event
                    FOR EACH ROW EXECUTE PROCEDURE delete_partition();""")

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_trigger('after_insert_row_for_delete_trigger')
    op.drop_trigger('before_insert_row_trigger')
    op.drop_trigger('after_insert_row_trigger')
    op.execute("""RAISE NOTICE 'NO YET DOWNGRADE FOR EVENT'""")
    # ### end Alembic commands ###
